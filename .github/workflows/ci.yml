name: CI Pipeline

on:
  push:
    branches: [main, dev]
    tags:
      - "v*"
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main, dev]

jobs:
  # Default Jobs: Build, Verify, Test
  # Runs on: Any branch -> dev (PR), dev -> main (PR), and direct pushes
  build-docker:
    # Skip on release commits and closed PRs to avoid duplication
    if: "!contains(github.event.head_commit.message, '[skip ci]') && (github.event_name != 'pull_request' || github.event.action != 'closed')"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      sanitized-branch: ${{ steps.branch-name.outputs.sanitized }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Determine branch name for image tagging
        id: branch-name
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, use the head ref (source branch)
            BRANCH_NAME="${{ github.head_ref }}"
          else
            # For pushes, use the current branch
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          # Sanitize branch name for Docker tags (replace / with -)
          SANITIZED_BRANCH_NAME="${BRANCH_NAME//\//-}"
          echo "name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "sanitized=${SANITIZED_BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Using branch name: ${BRANCH_NAME} (sanitized: ${SANITIZED_BRANCH_NAME})"

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for Docker file changes
        id: check-docker
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, check changes between base and head
            if git diff --name-only origin/${{ github.base_ref }}...${{ github.sha }} | grep -E '(docker/|uv\.lock)'; then
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "Docker files changed detected"
            else
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "No Docker file changes detected"
            fi
          else
            # For push events, check the latest commit
            if git rev-parse HEAD~1 >/dev/null 2>&1; then
              if git diff --name-only HEAD~1 HEAD | grep -E '(docker/|uv\.lock)'; then
                echo "changed=true" >> $GITHUB_OUTPUT
                echo "Docker files changed detected"
              else
                echo "changed=false" >> $GITHUB_OUTPUT
                echo "No Docker file changes detected"
              fi
            else
              # First commit, assume Docker files changed
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "First commit - Docker files assumed changed"
            fi
          fi

      - name: Check if branch-latest image exists
        id: check-image
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          IMAGE_TAG="ghcr.io/${{ github.repository }}-ci:${BRANCH_NAME}-latest"
          echo "Checking for image: ${IMAGE_TAG}"

          if docker manifest inspect "${IMAGE_TAG}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✓ Docker image ${IMAGE_TAG} exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "✗ Docker image ${IMAGE_TAG} does not exist"
          fi

      - name: Determine if build is needed
        id: should-build
        run: |
          DOCKER_CHANGED="${{ steps.check-docker.outputs.changed }}"
          IMAGE_EXISTS="${{ steps.check-image.outputs.exists }}"

          if [ "${DOCKER_CHANGED}" = "true" ] || [ "${IMAGE_EXISTS}" = "false" ]; then
            echo "build-needed=true" >> $GITHUB_OUTPUT
            echo "✓ Build required (Docker changed: ${DOCKER_CHANGED}, Image exists: ${IMAGE_EXISTS})"
          else
            echo "build-needed=false" >> $GITHUB_OUTPUT
            echo "✓ Build not required (Docker changed: ${DOCKER_CHANGED}, Image exists: ${IMAGE_EXISTS})"
          fi

      - name: Set up Docker Buildx
        if: steps.should-build.outputs.build-needed == 'true' || steps.check-image.outputs.exists == 'false'
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:latest

      - name: Extract metadata for Docker
        if: steps.should-build.outputs.build-needed == 'true' || steps.check-image.outputs.exists == 'false'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}-ci
          tags: type=raw,value=${{ steps.branch-name.outputs.sanitized }}-latest
          flavor: latest=false

      - name: Build and push Docker image
        if: steps.should-build.outputs.build-needed == 'true' || steps.check-image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/dev.dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            PY_VERSION=3.13
          cache-from: type=gha,scope=dev-image
          cache-to: type=gha,mode=max,scope=dev-image

      - name: Log build summary
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          BUILD_NEEDED="${{ steps.should-build.outputs.build-needed }}"

          echo "=== Build Summary ==="
          echo "Branch: ${BRANCH_NAME}"
          echo "Build performed: ${BUILD_NEEDED}"
          echo "Latest tag: ghcr.io/${{ github.repository }}-ci:${BRANCH_NAME}-latest"
          echo "======================"

      - name: Verify Docker image
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          IMAGE_TAG="ghcr.io/${{ github.repository }}-ci:${BRANCH_NAME}-latest"

          echo "Verifying image: ${IMAGE_TAG}"
          if docker manifest inspect "${IMAGE_TAG}" >/dev/null 2>&1; then
            echo "✓ Docker image exists and is accessible: ${IMAGE_TAG}"
          else
            echo "✗ Docker image verification failed: ${IMAGE_TAG}"
            exit 1
          fi

  test:
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest
    needs: build-docker
    permissions:
      contents: read
      packages: read
    container:
      # Note: env context is not available in container.image, so we use github.repository directly
      # Use sanitized branch name from build-docker job output to match built image tags
      image: ghcr.io/${{ github.repository }}-ci:${{ needs.build-docker.outputs.sanitized-branch }}-latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user root
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Run tox for all environments
        run: |
          echo "=== Running all tox environments ==="
          export PYTHONPATH="$(pwd)/src"
          export HOME="$(pwd)"
          # Ensure UV uses the pre-populated cache from Docker image
          export XDG_CACHE_HOME=/app/.cache
          tox run-parallel --parallel all

  # Delete Branch Job: Automatically delete PR branch after successful merge
  delete-branch:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Determine branch name
        id: branch-name
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          echo "name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Branch: ${BRANCH_NAME}"

          # Check if this is a feature branch (not dev or main)
          if [ "${BRANCH_NAME}" != "dev" ] && [ "${BRANCH_NAME}" != "main" ]; then
            echo "is_feature_branch=true" >> $GITHUB_OUTPUT
            echo "✓ Feature branch detected: ${BRANCH_NAME}"
          else
            echo "is_feature_branch=false" >> $GITHUB_OUTPUT
            echo "○ Skipping branch deletion for protected branch: ${BRANCH_NAME}"
          fi

      - name: Delete feature branch
        if: steps.branch-name.outputs.is_feature_branch == 'true'
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.name }}"
          REPO="${{ github.repository }}"

          echo "Deleting branch: ${BRANCH_NAME}"

          # Delete the branch using GitHub API
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
               -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github+json" \
               "https://api.github.com/repos/${REPO}/git/refs/heads/${BRANCH_NAME}")

          if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "✓ Successfully deleted branch: ${BRANCH_NAME} (HTTP ${HTTP_CODE})"
          else
            echo "✗ Failed to delete branch: ${BRANCH_NAME} (HTTP ${HTTP_CODE})"
            exit 1
          fi

  # Release Job: Runs after merge to main (Post-Merge)
  release:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    needs: [build-docker, test]
    permissions:
      contents: write
      packages: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        
      - name: Setup Node.js
        uses: cycjimmy/semantic-release-action@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with: 
          extra_plugins: |
            @semantic-release/changelog@6
            @semantic-release/git@10
            @semantic-release/github@10
            @semantic-release/exec@6
            conventional-changelog-conventionalcommits@7
          
      - name: Check if release was created
        id: check-release
        run: |
          # Check if there's a new tag created by semantic-release
          LATEST_TAG=$(git describe --tags --abbrev=0 HEAD 2>/dev/null || echo "")

          # Check if the latest tag points to the current HEAD
          if [ -n "$LATEST_TAG" ]; then
            TAG_COMMIT=$(git rev-list -n 1 "$LATEST_TAG" 2>/dev/null || echo "")
            CURRENT_COMMIT=$(git rev-parse HEAD)

            if [ "$TAG_COMMIT" = "$CURRENT_COMMIT" ]; then
              echo "release_created=true" >> $GITHUB_OUTPUT
              echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
              echo "Release created: $LATEST_TAG"
            else
              echo "release_created=false" >> $GITHUB_OUTPUT
              echo "No new release created (latest tag $LATEST_TAG is not on current commit)"
            fi
          else
            echo "release_created=false" >> $GITHUB_OUTPUT
            echo "No tags found, no release created"
          fi

      - name: Back-merge to dev
        if: steps.check-release.outputs.release_created == 'true'
        run: |
          # Fetch the latest changes
          git fetch origin main dev

          # Check if dev branch exists
          if git ls-remote --heads origin dev | grep -q dev; then
            echo "Dev branch exists, proceeding with back-merge"

            # Checkout dev branch
            git checkout dev
            git pull origin dev

            # Merge main into dev
            git merge origin/main -m "chore: back-merge main into dev [skip ci]"

            # Push to dev
            git push origin dev

            echo "✓ Successfully back-merged main to dev"
          else
            echo "Dev branch does not exist, skipping back-merge"
          fi

  # Publish to PyPI Job: Publishes the wheel file to PyPI after successful release
  publish-to-pypi:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && !contains(github.event.head_commit.message, '[skip ci]')
    needs: release
    # if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/structcast
    permissions:
      contents: read
      id-token: write # IMPORTANT: mandatory for trusted publishing
    steps:
      - name: Get latest release
        id: get-release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the latest release information
          RELEASE_INFO=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                              -H "Accept: application/vnd.github+json" \
                              "https://api.github.com/repos/${{ github.repository }}/releases/latest")

          RELEASE_TAG=$(echo "$RELEASE_INFO" | jq -r '.tag_name')
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')

          if [ "$RELEASE_TAG" = "null" ] || [ -z "$RELEASE_TAG" ]; then
            echo "No release found, skipping publish"
            echo "has_release=false" >> $GITHUB_OUTPUT
          else
            echo "has_release=true" >> $GITHUB_OUTPUT
            echo "tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
            echo "id=$RELEASE_ID" >> $GITHUB_OUTPUT
            echo "Found release: $RELEASE_TAG (ID: $RELEASE_ID)"
          fi

      - name: Download wheel from release
        if: steps.get-release.outputs.has_release == 'true'
        run: |
          RELEASE_TAG="${{ steps.get-release.outputs.tag }}"

          # Get release assets
          ASSETS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                        -H "Accept: application/vnd.github+json" \
                        "https://api.github.com/repos/${{ github.repository }}/releases/tags/${RELEASE_TAG}")

          # Find the wheel file (.whl)
          WHEEL_URL=$(echo "$ASSETS" | jq -r '.assets[] | select(.name | endswith(".whl")) | .browser_download_url' | head -n 1)
          WHEEL_NAME=$(echo "$ASSETS" | jq -r '.assets[] | select(.name | endswith(".whl")) | .name' | head -n 1)

          if [ -z "$WHEEL_URL" ] || [ "$WHEEL_URL" = "null" ]; then
            echo "No wheel file found in release"
            exit 1
          fi

          echo "Downloading wheel: $WHEEL_NAME"
          echo "From: $WHEEL_URL"

          # Create dist directory and download the wheel
          mkdir -p dist
          curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/octet-stream" \
               -o "dist/$WHEEL_NAME" \
               "$WHEEL_URL"

          echo "✓ Successfully downloaded: dist/$WHEEL_NAME"
          ls -lh dist/

      - name: Publish to PyPI
        if: steps.get-release.outputs.has_release == 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          skip-existing: true
          verbose: true
          print-hash: true
