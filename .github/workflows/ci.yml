name: CI Pipeline

on:
  push:
    branches: [main, dev]
    tags:
      - "v*"
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main, dev]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Default Jobs: Build, Verify, Test
  # Runs on: Any branch -> dev (PR), dev -> main (PR), and direct pushes
  build-docker:
    # Skip on release commits and closed PRs to avoid duplication
    if: "!contains(github.event.head_commit.message, '[skip ci]') && (github.event_name != 'pull_request' || github.event.action != 'closed')"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12", "3.13"]
    outputs:
      sanitized-branch: ${{ steps.branch-name.outputs.sanitized }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine branch name for image tagging
        id: branch-name
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, use the head ref (source branch)
            BRANCH_NAME="${{ github.head_ref }}"
          else
            # For pushes, use the current branch
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          # Sanitize branch name for Docker tags (replace / with -)
          SANITIZED_BRANCH_NAME="${BRANCH_NAME//\//-}"
          echo "name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "sanitized=${SANITIZED_BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Using branch name: ${BRANCH_NAME} (sanitized: ${SANITIZED_BRANCH_NAME})"

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for Docker file changes
        id: check-docker
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, check changes between base and head
            if git diff --name-only origin/${{ github.base_ref }}...${{ github.sha }} | grep -E '(docker/|uv\.lock)'; then
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "Docker files changed detected"
            else
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "No Docker file changes detected"
            fi
          else
            # For push events, check the latest commit
            if git rev-parse HEAD~1 >/dev/null 2>&1; then
              if git diff --name-only HEAD~1 HEAD | grep -E '(docker/|uv\.lock)'; then
                echo "changed=true" >> $GITHUB_OUTPUT
                echo "Docker files changed detected"
              else
                echo "changed=false" >> $GITHUB_OUTPUT
                echo "No Docker file changes detected"
              fi
            else
              # First commit, assume Docker files changed
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "First commit - Docker files assumed changed"
            fi
          fi

      - name: Check if branch-latest image exists
        id: check-image
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          PY_VERSION="${{ matrix.python-version }}"
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${BRANCH_NAME}-py${PY_VERSION}-latest"
          echo "Checking for image: ${IMAGE_TAG}"

          if docker pull "${IMAGE_TAG}" 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✓ Docker image ${IMAGE_TAG} exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "✗ Docker image ${IMAGE_TAG} does not exist"
          fi

      - name: Determine if build is needed
        id: should-build
        run: |
          DOCKER_CHANGED="${{ steps.check-docker.outputs.changed }}"
          IMAGE_EXISTS="${{ steps.check-image.outputs.exists }}"
          PY_VERSION="${{ matrix.python-version }}"
          PY_VERSION_NORMALIZED="${PY_VERSION//./-}"

          if [ "${DOCKER_CHANGED}" = "true" ] || [ "${IMAGE_EXISTS}" = "false" ]; then
            echo "build-${PY_VERSION_NORMALIZED}=true" >> $GITHUB_OUTPUT
            echo "build-needed=true" >> $GITHUB_OUTPUT
            echo "✓ Build required for Python ${PY_VERSION} (Docker changed: ${DOCKER_CHANGED}, Image exists: ${IMAGE_EXISTS})"
          else
            echo "build-${PY_VERSION_NORMALIZED}=false" >> $GITHUB_OUTPUT
            echo "build-needed=false" >> $GITHUB_OUTPUT
            echo "✓ Build not required for Python ${PY_VERSION} (Docker changed: ${DOCKER_CHANGED}, Image exists: ${IMAGE_EXISTS})"
          fi
          echo "py-version-normalized=${PY_VERSION_NORMALIZED}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        if: steps.should-build.outputs.build-needed == 'true' || steps.check-image.outputs.exists == 'false'
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:latest

      - name: Extract metadata for Docker
        if: steps.should-build.outputs.build-needed == 'true' || steps.check-image.outputs.exists == 'false'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.branch-name.outputs.sanitized }}-py${{ matrix.python-version }}-{{sha}}
            type=raw,value=${{ steps.branch-name.outputs.sanitized }}-py${{ matrix.python-version }}-latest
          flavor: |
            latest=false
          # Note: Using centralized sanitized branch-name output for consistent tagging
          # {{sha}} is automatically truncated to 7 characters by the metadata action

      - name: Build and push Docker image
        if: steps.should-build.outputs.build-needed == 'true' || steps.check-image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/dev.dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            PY_VERSION=${{ matrix.python-version }}
          cache-from: type=gha,scope=py${{ matrix.python-version }}
          cache-to: type=gha,mode=max,scope=py${{ matrix.python-version }}

      - name: Log build summary
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          PY_VERSION="${{ matrix.python-version }}"
          BUILD_NEEDED="${{ steps.should-build.outputs.build-needed }}"

          echo "=== Build Summary ==="
          echo "Branch: ${BRANCH_NAME}"
          echo "Python: ${PY_VERSION}"
          echo "Build performed: ${BUILD_NEEDED}"
          echo "Latest tag: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${BRANCH_NAME}-py${PY_VERSION}-latest"
          echo "====================="

      - name: Verify Docker image
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          PY_VERSION="${{ matrix.python-version }}"
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${BRANCH_NAME}-py${PY_VERSION}-latest"

          echo "Verifying image: ${IMAGE_TAG}"
          if docker pull "${IMAGE_TAG}" 2>/dev/null; then
            echo "✓ Docker image exists and is accessible: ${IMAGE_TAG}"
          else
            echo "✗ Docker image verification failed: ${IMAGE_TAG}"
            exit 1
          fi

  test:
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest
    needs: build-docker
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12", "3.13"]
    container:
      # Note: env context is not available in container.image, so we use github.repository directly
      # Use sanitized branch name from build-docker job output to match built image tags
      image: ghcr.io/${{ github.repository }}:${{ needs.build-docker.outputs.sanitized-branch }}-py${{ matrix.python-version }}-latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run tests
        run: |
          echo "=== Python Version ==="
          export PYTHONPATH="$(pwd)/src"
          python --version

          echo "=== Code Quality Checks ==="
          ruff format --check src/ tests/
          ruff check src/ tests/
          mypy src/
          mypy tests/

          echo "=== Running Tests ==="
          pytest

  # Cleanup Job: Delete Docker images for feature branches after successful PR merge
  cleanup-images:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: Determine branch name
        id: branch-name
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          # Sanitize branch name for Docker tags (replace / with -)
          SANITIZED_BRANCH_NAME="${BRANCH_NAME//\//-}"
          echo "sanitized=${SANITIZED_BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Branch: ${BRANCH_NAME} (sanitized: ${SANITIZED_BRANCH_NAME})"

          # Check if this is a feature branch (not dev or main)
          if [ "${BRANCH_NAME}" != "dev" ] && [ "${BRANCH_NAME}" != "main" ]; then
            echo "is_feature_branch=true" >> $GITHUB_OUTPUT
            echo "✓ Feature branch detected: ${BRANCH_NAME}"
          else
            echo "is_feature_branch=false" >> $GITHUB_OUTPUT
            echo "○ Skipping cleanup for protected branch: ${BRANCH_NAME}"
          fi

      - name: Delete feature branch Docker images
        if: steps.branch-name.outputs.is_feature_branch == 'true'
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.sanitized }}"
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"

          echo "Cleaning up Docker images for feature branch: ${BRANCH_NAME}"

          # Get package versions for this branch
          PACKAGE_URL="https://api.github.com/users/${REPO_OWNER}/packages/container/${REPO_NAME}/versions"

          # Use GitHub CLI to list and delete images
          # Delete both -latest and -sha tagged images for this branch (all Python versions)
          echo "Searching for images with tags matching: ${BRANCH_NAME}-py*"

          # Get all versions
          VERSIONS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                          -H "Accept: application/vnd.github+json" \
                          "${PACKAGE_URL}" | jq -r '.[] | select(.metadata.container.tags[] | test("^'${BRANCH_NAME}'-py[0-9.]+")) | .id')

          if [ -z "$VERSIONS" ]; then
            echo "No images found for branch ${BRANCH_NAME}"
          else
            echo "Found images to delete:"
            for VERSION_ID in $VERSIONS; do
              # Get tag names for logging
              TAGS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                          -H "Accept: application/vnd.github+json" \
                          "${PACKAGE_URL}/${VERSION_ID}" | jq -r '.metadata.container.tags[]' | tr '\n' ', ')
              
              echo "  Deleting version ${VERSION_ID} (tags: ${TAGS})"
              
              curl -X DELETE \
                   -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                   -H "Accept: application/vnd.github+json" \
                   "https://api.github.com/users/${REPO_OWNER}/packages/container/${REPO_NAME}/versions/${VERSION_ID}"
              
              if [ $? -eq 0 ]; then
                echo "  ✓ Deleted successfully"
              else
                echo "  ✗ Failed to delete (may require manual cleanup)"
              fi
            done
            echo "✓ Cleanup completed for branch: ${BRANCH_NAME}"
          fi

      - name: Delete untagged Docker images
        if: steps.branch-name.outputs.is_feature_branch == 'false'
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"

          echo "Cleaning up untagged Docker images"

          # Get package versions for this repository
          PACKAGE_URL="https://api.github.com/users/${REPO_OWNER}/packages/container/${REPO_NAME}/versions"

          # Find all untagged versions (versions with empty tags array)
          echo "Searching for untagged images..."

          UNTAGGED_VERSIONS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                                   -H "Accept: application/vnd.github+json" \
                                   "${PACKAGE_URL}" | jq -r '.[] | select(.metadata.container.tags | length == 0) | .id')

          if [ -z "$UNTAGGED_VERSIONS" ]; then
            echo "No untagged images found"
          else
            echo "Found untagged images to delete:"
            for VERSION_ID in $UNTAGGED_VERSIONS; do
              echo "  Deleting untagged version ${VERSION_ID}"
              
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
                   -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                   -H "Accept: application/vnd.github+json" \
                   "https://api.github.com/users/${REPO_OWNER}/packages/container/${REPO_NAME}/versions/${VERSION_ID}")
              
              if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
                echo "  ✓ Deleted successfully (HTTP ${HTTP_CODE})"
              else
                echo "  ✗ Failed to delete (HTTP ${HTTP_CODE})"
              fi
            done
            echo "✓ Untagged images cleanup completed"
          fi

  # Delete Branch Job: Automatically delete PR branch after successful merge
  delete-branch:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Determine branch name
        id: branch-name
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          echo "name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Branch: ${BRANCH_NAME}"

          # Check if this is a feature branch (not dev or main)
          if [ "${BRANCH_NAME}" != "dev" ] && [ "${BRANCH_NAME}" != "main" ]; then
            echo "is_feature_branch=true" >> $GITHUB_OUTPUT
            echo "✓ Feature branch detected: ${BRANCH_NAME}"
          else
            echo "is_feature_branch=false" >> $GITHUB_OUTPUT
            echo "○ Skipping branch deletion for protected branch: ${BRANCH_NAME}"
          fi

      - name: Delete feature branch
        if: steps.branch-name.outputs.is_feature_branch == 'true'
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.name }}"
          REPO="${{ github.repository }}"

          echo "Deleting branch: ${BRANCH_NAME}"

          # Delete the branch using GitHub API
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
               -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github+json" \
               "https://api.github.com/repos/${REPO}/git/refs/heads/${BRANCH_NAME}")

          if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "✓ Successfully deleted branch: ${BRANCH_NAME} (HTTP ${HTTP_CODE})"
          else
            echo "✗ Failed to delete branch: ${BRANCH_NAME} (HTTP ${HTTP_CODE})"
            exit 1
          fi

  # Release Job: Runs after merge to main (Post-Merge)
  release:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    needs: [test]
    permissions:
      contents: write
      packages: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install semantic-release
        run: |
          npm install -g semantic-release@23 \
            @semantic-release/changelog@6 \
            @semantic-release/git@10 \
            @semantic-release/github@10 \
            @semantic-release/exec@6 \
            conventional-changelog-conventionalcommits@7

      - name: Install uv
        run: |
          set -e
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          # Verify uv is installed
          export PATH="$HOME/.cargo/bin:$PATH"
          uv --version

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run Semantic Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          npx semantic-release

      - name: Check if release was created
        id: check-release
        run: |
          # Check if there's a new tag created by semantic-release
          LATEST_TAG=$(git describe --tags --abbrev=0 HEAD 2>/dev/null || echo "")

          # Check if the latest tag points to the current HEAD
          if [ -n "$LATEST_TAG" ]; then
            TAG_COMMIT=$(git rev-list -n 1 "$LATEST_TAG" 2>/dev/null || echo "")
            CURRENT_COMMIT=$(git rev-parse HEAD)

            if [ "$TAG_COMMIT" = "$CURRENT_COMMIT" ]; then
              echo "release_created=true" >> $GITHUB_OUTPUT
              echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
              echo "Release created: $LATEST_TAG"
            else
              echo "release_created=false" >> $GITHUB_OUTPUT
              echo "No new release created (latest tag $LATEST_TAG is not on current commit)"
            fi
          else
            echo "release_created=false" >> $GITHUB_OUTPUT
            echo "No tags found, no release created"
          fi

      - name: Back-merge to dev
        if: steps.check-release.outputs.release_created == 'true'
        run: |
          # Fetch the latest changes
          git fetch origin main dev

          # Check if dev branch exists
          if git ls-remote --heads origin dev | grep -q dev; then
            echo "Dev branch exists, proceeding with back-merge"

            # Checkout dev branch
            git checkout dev
            git pull origin dev

            # Merge main into dev
            git merge origin/main -m "chore: back-merge main into dev [skip ci]"

            # Push to dev
            git push origin dev

            echo "✓ Successfully back-merged main to dev"
          else
            echo "Dev branch does not exist, skipping back-merge"
          fi
